using System.Text;
using Game.Tools.Proto;

namespace Game.Tools.CodeGen;

/// <summary>
/// Generates C# MemoryTable class source from a <see cref="TableDefinition"/>.
/// </summary>
public class CSharpClassGenerator
{
    /// <summary>
    /// Generate a C# source file for the given table definition.
    /// </summary>
    /// <param name="table">Table definition parsed from proto.</param>
    /// <param name="targetNamespace">Target namespace for the generated class.</param>
    /// <param name="targetLabel">Label for the target (e.g., "Client", "Server").</param>
    /// <param name="targetBit">Target bitmask bit for field filtering.</param>
    /// <returns>Complete C# source code as a string.</returns>
    public string Generate(TableDefinition table, string targetNamespace, string targetLabel, int targetBit)
    {
        var sb = new StringBuilder();

        // Header comment
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// Generated from {table.ProtoFile}");
        sb.AppendLine($"// Target: {targetLabel}");
        sb.AppendLine("// </auto-generated>");

        // Using statements
        sb.AppendLine("using MasterMemory;");
        sb.AppendLine("using MessagePack;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {targetNamespace}");
        sb.AppendLine("{");

        // Class declaration
        sb.AppendLine($"    [MemoryTable(\"{table.TableName}\"), MessagePackObject(true)]");
        sb.AppendLine($"    public sealed partial class {table.TableName}");
        sb.AppendLine("    {");

        // Merge field-level and message-level secondary key definitions
        var allSecondaryKeys = BuildSecondaryKeyMap(table);

        // Filter fields by target
        var fields = table.Fields
            .Where(f => DeployTargetHelper.ShouldInclude(f.DeployTarget, targetBit))
            .ToList();

        for (int i = 0; i < fields.Count; i++)
        {
            var field = fields[i];
            var attributes = BuildAttributes(field, table, allSecondaryKeys);

            foreach (var attr in attributes)
            {
                sb.AppendLine($"        {attr}");
            }

            sb.AppendLine($"        public {field.CSharpType} {field.CSharpName} {{ get; set; }}");

            if (i < fields.Count - 1)
            {
                sb.AppendLine();
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Build a map of field name â†’ list of secondary key attributes from both
    /// field-level options and message-level secondary_keys options.
    /// </summary>
    private static Dictionary<string, List<SecondaryKeyInfo>> BuildSecondaryKeyMap(TableDefinition table)
    {
        var map = new Dictionary<string, List<SecondaryKeyInfo>>();

        // Collect from field-level options
        foreach (var field in table.Fields)
        {
            if (field.SecondaryKeys.Count > 0)
            {
                if (!map.ContainsKey(field.ProtoName))
                {
                    map[field.ProtoName] = [];
                }

                map[field.ProtoName].AddRange(field.SecondaryKeys);
            }
        }

        // Collect from message-level secondary_keys
        foreach (var skDef in table.SecondaryKeys)
        {
            if (!map.ContainsKey(skDef.FieldName))
            {
                map[skDef.FieldName] = [];
            }

            map[skDef.FieldName].Add(new SecondaryKeyInfo
            {
                Index = skDef.SecondaryIndex,
                KeyOrder = skDef.KeyOrder,
                NonUnique = skDef.NonUnique,
            });
        }

        return map;
    }

    private static List<string> BuildAttributes(
        FieldDefinition field,
        TableDefinition table,
        Dictionary<string, List<SecondaryKeyInfo>> allSecondaryKeys)
    {
        var attributes = new List<string>();

        // Primary key
        if (field.IsPrimaryKey)
        {
            bool isComposite = table.Fields.Count(f => f.IsPrimaryKey) > 1;
            if (isComposite)
            {
                attributes.Add($"[PrimaryKey({field.PrimaryKeyOrder})]");
            }
            else
            {
                attributes.Add("[PrimaryKey]");
            }
        }

        // Secondary keys
        if (allSecondaryKeys.TryGetValue(field.ProtoName, out var sks))
        {
            // Determine which SK indices are composite (multiple fields participate)
            var compositeIndices = allSecondaryKeys.Values
                .SelectMany(skList => skList)
                .GroupBy(sk => sk.Index)
                .Where(g => g.Count() > 1)
                .Select(g => g.Key)
                .ToHashSet();

            // Sort by index for deterministic output
            var sortedSks = sks.OrderBy(sk => sk.Index).ThenBy(sk => sk.KeyOrder).ToList();

            foreach (var sk in sortedSks)
            {
                var attrParts = new List<string>();

                // Specify keyOrder when composite SK or keyOrder > 0
                bool needsKeyOrder = sk.KeyOrder > 0 || compositeIndices.Contains(sk.Index);

                if (needsKeyOrder)
                {
                    attrParts.Add($"SecondaryKey({sk.Index}, keyOrder: {sk.KeyOrder})");
                }
                else
                {
                    attrParts.Add($"SecondaryKey({sk.Index})");
                }

                if (sk.NonUnique)
                {
                    attrParts.Add("NonUnique");
                }

                attributes.Add($"[{string.Join(", ", attrParts)}]");
            }
        }

        return attributes;
    }
}
